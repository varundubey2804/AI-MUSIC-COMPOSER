<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machina Core</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #status {
            position: absolute; bottom: 20px; left: 20px;
            color: #00FF9D; font-family: 'Courier New', monospace;
            font-size: 10px; letter-spacing: 2px; pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>
    <div id="status">CORE_SYSTEM: ONLINE</div>

    <script type="x-shader/x-vertex" id="vShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform float time;
        void main() {
            vUv = uv;
            vNormal = normal;
            vec3 pos = position;
            // Industrial breathing effect
            float pulse = sin(time * 3.0 + position.y * 5.0) * 0.05;
            pos += normal * pulse;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="fShader">
        uniform float time;
        uniform vec3 color;
        varying vec2 vUv;
        varying vec3 vNormal;
        void main() {
            // Energy Bands
            float bands = sin(vUv.y * 30.0 - time * 8.0);
            float intensity = smoothstep(0.9, 1.0, bands) * 0.8 + 0.2;
            
            // Rim Light
            float rim = 1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0));
            rim = pow(rim, 3.0);
            
            vec3 finalColor = color * intensity + (rim * vec3(0.8, 1.0, 0.9));
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // --- 1. PYTHON DATA INJECTION ---
        // Python will replace 'null' with actual JSON data
        const DATA = null; 
        
        // --- 2. CONFIG ---
        const CFG = {
            mint: 0x00FF9D,
            copper: 0xC4804E,
            bg: 0x050505,
            particles: 600
        };

        // --- 3. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CFG.bg, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 12;

        const renderer = new THREE.WebGLRenderer({antialias: true, alpha:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf Opt
        document.body.appendChild(renderer.domElement);

        // --- 4. OBJECTS ---
        
        // A. REACTOR CORE (Shader)
        const coreMat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: {
                time: {value: 0},
                color: {value: new THREE.Color(CFG.mint)}
            },
            wireframe: true
        });
        const core = new THREE.Mesh(new THREE.IcosahedronGeometry(2.5, 1), coreMat);
        scene.add(core);

        // B. COPPER RINGS
        const rings = new THREE.Group();
        const ringGeo = new THREE.TorusGeometry(4.5, 0.02, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({color: CFG.copper});
        for(let i=0; i<4; i++){
            let r = new THREE.Mesh(ringGeo, ringMat);
            r.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
            rings.add(r);
        }
        scene.add(rings);

        // C. PARTICLE TUNNEL (InstancedMesh)
        const pGeo = new THREE.BoxGeometry(0.05, 0.05, 0.5);
        const pMat = new THREE.MeshBasicMaterial({color: CFG.mint});
        const particles = new THREE.InstancedMesh(pGeo, pMat, CFG.particles);
        const dummy = new THREE.Object3D();
        const pData = [];
        
        for(let i=0; i<CFG.particles; i++){
            const rad = 6 + Math.random() * 15;
            const ang = Math.random() * Math.PI * 2;
            const z = (Math.random() - 0.5) * 40;
            dummy.position.set(Math.cos(ang)*rad, Math.sin(ang)*rad, z);
            dummy.rotation.set(Math.random(), Math.random(), Math.random());
            dummy.updateMatrix();
            particles.setMatrixAt(i, dummy.matrix);
            pData.push({speed: 0.02 + Math.random()*0.05, z: z});
        }
        scene.add(particles);

        // --- 5. POST PROCESSING (BLOOM) ---
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // --- 6. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            
            // Core Animation
            coreMat.uniforms.time.value = t;
            core.rotation.y += 0.005;
            rings.rotation.y -= 0.002;
            
            // Particle Tunnel
            let speedMult = (DATA && DATA.state === 'generating') ? 8.0 : 1.0;
            
            for(let i=0; i<CFG.particles; i++){
                particles.getMatrixAt(i, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.rotation, dummy.scale);
                
                dummy.position.z += pData[i].speed * speedMult;
                if(dummy.position.z > 20) dummy.position.z = -20;
                
                dummy.updateMatrix();
                particles.setMatrixAt(i, dummy.matrix);
            }
            particles.instanceMatrix.needsUpdate = true;
            
            composer.render();
        }
        
        // --- 7. DATA REACTION ---
        if(DATA && DATA.state === 'generating') {
            gsap.to(camera.position, {z: 8, duration: 1.5, ease: "expo.out"});
            gsap.to(bloomPass, {strength: 2.5, duration: 0.5});
            document.getElementById('status').innerText = "STATUS: SYNTHESIZING...";
            document.getElementById('status').style.color = "#fff";
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>